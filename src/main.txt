#include <Arduino.h>
#include "config.h"
#include "eXoCAN.h"


HardwareSerial mySerial(USART1);

eXoCAN can;  // Initialize eXoCAN object

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏≤‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°
struct TPIC6B595 {
    uint8_t dataPin;
    uint8_t clockPin;
    uint8_t latchPin;
    uint16_t ledState; // ‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ LED ‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡∏∏‡πà‡∏°
};

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡∏≤‡πÉ‡∏´‡πâ‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏Å‡∏•‡∏∏‡πà‡∏°
TPIC6B595 groupA = {PA0, PA1, PA2, 0};
TPIC6B595 groupB = {PA3, PA4, PA5, 0};


void bink(){
    digitalWrite(PC13, LOW);
    delay(50);
    digitalWrite(PC13, HIGH);
    delay(50);
    digitalWrite(PC13, LOW);
    delay(50);
    digitalWrite(PC13, HIGH);
    delay(50);
  
  }

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏õ‡∏¢‡∏±‡∏á TPIC6B595N (16-bit)
void shiftOutTPIC16(TPIC6B595 &group) {
    digitalWrite(group.latchPin, LOW); // ‡∏õ‡∏¥‡∏î Latch ‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
    for (int i = 15; i >= 0; i--) {
        digitalWrite(group.clockPin, LOW);
        digitalWrite(group.dataPin, (group.ledState >> i) & 0x01);
        digitalWrite(group.clockPin, HIGH);
    }
    digitalWrite(group.latchPin, HIGH); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Latch
}

// ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° LED ‡∏ó‡∏µ‡∏•‡∏∞‡∏î‡∏ß‡∏á
void setLED(TPIC6B595 &group, uint8_t index) {
    if (index > 15) return; // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏Å‡∏¥‡∏ô 16 ‡∏ö‡∏¥‡∏ï
    group.ledState = (1 << index); // ‡πÄ‡∏õ‡∏¥‡∏î‡πÄ‡∏â‡∏û‡∏≤‡∏∞ LED ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å
    shiftOutTPIC16(group); // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï LED
}

void setup() {

    mySerial.begin(115200);
    pinMode(PC13, OUTPUT);
    digitalWrite(PC13, HIGH);

    // Initialize CAN with standard ID length, 250kbps baud rate, using PA11/PA12 pins
    can.begin(STD_ID_LEN, BR250K, PORTA_11_12_XCVR);
    mySerial.println("‚úÖ CAN Bus Initialized - Listening for Messages...");
    // ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏Ç‡∏≤‡πÄ‡∏õ‡πá‡∏ô OUTPUT
    pinMode(groupA.dataPin, OUTPUT);
    pinMode(groupA.clockPin, OUTPUT);
    pinMode(groupA.latchPin, OUTPUT);

    pinMode(groupB.dataPin, OUTPUT);
    pinMode(groupB.clockPin, OUTPUT);
    pinMode(groupB.latchPin, OUTPUT);

    digitalWrite(groupA.latchPin, LOW);
    digitalWrite(groupB.latchPin, LOW);
}

void loop() {


    volatile int rxID;        // Change uint32_t to volatile int
    volatile int rxFltrIdx;   // Extra argument required by eXoCAN
    uint8_t rxData[8];        // Array to store received CAN data

    // Check for incoming CAN messages
    if (can.receive(rxID, rxFltrIdx, rxData)) {
      if(rxID == 0x069){
        bink();
        mySerial.print("üì• Received CAN ID: 0x");
        mySerial.print(rxID, HEX);
        mySerial.print(" | Data: ");

        // Print received data as hex values
        for (int i = 0; i < 8; i++) {
            mySerial.print("0x");
            if (rxData[i] < 0x10) mySerial.print("0");  // Add leading zero if necessary
            mySerial.print(rxData[i], HEX);
            mySerial.print(" ");

        }

        mySerial.println();  // New line for better readability
        setLED(groupA, rxData[1]);
        setLED(groupB, rxData[0]);

      }
    }
    
}
